# [剑指 Offer 18]删除链表的节点	60.0%	Easy	0.0%#
我的思路：双针或者辅助栈，检测到了直接指向下一个.next.next
题解思路：单指针就可以
```
class Solution {
    public ListNode deleteNode(ListNode head, int val) {
        if (head.val ==val) return  head.next;
        ListNode pre=head,cur=head.next;
        while (cur != null && cur.val != val){
            pre =cur;
            cur =cur.next;

        }
            pre.next = cur.next;
            return head;


    }
}
```
#     [剑指 Offer 19]正则表达式匹配	38.5%	Hard	0.0%

做不出来
直接题解思路：
```
class Solution {
    /* dp三部曲: 
    1. dp[i][j]表示当字符串s长度为i,字符串p长度为j时，s与p是否匹配
    2.dp之间的关系：比较s[i]和p[j]两个字符：画图来分别描述下面的情况
        2.1 p[j]为普通字符
            如果s[j]等于p[j]，则dp[i][j] = dp[i-1][j-1] 取决于前面一个的值
            如果s[j]不等于p[j]，则dp[i][j]=false
        2.2 如果p[j]为'.'表示任意一个字符，dp[i][j] = dp[i-1][j-1]，这里可以跟2.1的第一种情况合并
        2.3 如果p[j]为'*',此时需要考虑p[j-1]这个字符，因为*跟着前一个字符走的
            如果p[j-1]不等于s[i]，只能把*当做0个前面的字符 dp[i][j] = dp[i][j-2]
            如果p[j-1]等于s[i]，需要分情况，以下三个情况有一个为true就是true，所以是下面三个结果相或
                如果*表示0个前一个字符 dp[i][j] = dp[i][j-2]
                如果*匹配一个字符 dp[i][j] = dp[i][j-1]
                如果*匹配多个字符,可以把多个字符和s[i]这个相同字符同时消除掉(
                    消除后p[j]还是不变，因为本来就这个分支表示多个了，
                    所以变成s[i-1]和p[j]比较是否匹配了)dp[i][j]=dp[i-1][j] 
    3.寻找dp初始值，寻找dp初始值的主要目的有两个，一个是为了方便循环根据前面的初始dp值获取后面的dp值，
    一个是为了防止我们的dp[i][j]数组越界，本题我们i遍历是从1开始(因为会有i-1) j从2开始(因为会有j-2)
        dp[0][0]= true 两个长度都为0直接为true
        dp[0][1]= fasle   dp[0][2]需要看第二个字符是否是*，是*则为true否则为false
    */
    public boolean isMatch(String s, String p) { 
        // 先排除特殊情况防止空指针
        if (s == null || p == null) {
            return false;
        }
        int n = s.length();
        int m = p.length();
        // 因为这里最终结果要表示dp[n][m]，数组下标又是从0开始，所以这里容量都要+1
        boolean[][] dp = new boolean[n+1][m+1];
        dp[0][0] = true;
        // 初始化首行
        for (int j = 2; j <= m; j++) {
            if (p.charAt(j-1) == '*') {  // 为*的时候相当于可以把前面两个消除了
                dp[0][j] = dp[0][j-2];
            }
        }
        // 注意下面每次charAt的时候都要多-1,因为下标从0开始
        for (int i = 1; i <=n; i++) {
            // dp公式虽然用到了j-2但是这里j-1不会越界，因为如果j为1的时候是不可能走进下面带'*'字符的逻辑的
            // 因为*不可能出现在第一个字符，所以当j=1的时候是不会走到* else分支去进行j-2操作的
            for (int j = 1; j <= m; j++) {
                if (p.charAt(j-1) == '.') {  // p[j]为'.'
                    dp[i][j] = dp[i-1][j-1];
                } else if (p.charAt(j-1) == '*') {  //p[j]为'*' 分多钟情况讨论
                    // 第j-1个字符和第i个字符不匹配  且  第j-1个字符不为'.'
                    if (p.charAt(j-2) != s.charAt(i-1) && p.charAt(j-2) != '.') {
                        dp[i][j] = dp[i][j-2];
                    } else { // p[j-1]和s[i]相等，'*'匹配0个、1个以及多个s[i]的情况求活
                        dp[i][j] = dp[i][j-2] || dp[i][j-1] || dp[i-1][j];
                    }
                } else { // p[j]为普通字符
                    if (p.charAt(j-1) == s.charAt(i-1)) {
                        dp[i][j] = dp[i-1][j-1];
                    } else {
                        dp[i][j] = false;
                    }
                }
            }
        }
        return dp[n][m];
        /*
        dp五部曲:(参考最高赞的思路)
        设原始串s的长度为m,模式串p的长度为n
        注意定义:'*'表示它前面的(一个)字符可以出现任意次（含0次）!注意是一个
        1.状态定义:设dp[i][j]为考虑s[0,i-1],p[0,j-1]时,是否能匹配上,匹配上就为true
        2.状态转移:
            2.1 p[j-1]为非'*'
                2.1.1 若p[j-1]==s[i-1](必定为'a'-'z'),继续看dp[i-1][j-1]
                2.1.2 若p[j-1]为'.',直接看dp[i-1][j-1]
            2.2 p[j-1]为'*'
                2.2.1 若p[j-2]==s[i-1](必定为'a'-'z'),则继续向前看dp[i-1][j]
                    因为对于p[0,j-1]来说,s[i-1]是冗余匹配可以由p[j-2]*补充
                2.2.2 p[j-2]为'.',则'.'匹配了s[i-1],可以继续往前看dp[i-1][j]
                    注意这里是".*"的情形,也就是"万能串",生成"......"可以匹配任何非空s
                2.2.3 此时p[j-2]为'a'-'z',且p[j-2]!=s[i-1],"p[j-2]*"直接废掉,看dp[i][j-2]
            其中2.1.1和2.1.2可以合并为一种情形;2.2.1和2.2.2可以合并为一种情形
        3.初始化:
            3.1 空的p 
                3.1.1 可以匹配空的s,dp[0][0]=true
                3.1.2 不可以匹配非空的s,dp[i][0]=false,i∈[1,m-1]
            3.2 空的s
                3.2.1 可以匹配空的s,dp[0][0]=true
                3.2.2 可能可以匹配非空的p,要经过计算如"a*b*c*"
            3.3 非空的p与非空的s,要经过计算
        4.遍历顺序:显然是正序遍历
        5.返回形式:直接返回dp[m][n]就表示考虑s[0,m-1],j[0,n-1]是否能匹配上
        */
    }
}
```